# Testing Laravel

### Requirements
1. PHP >= 7.1.3
2. OpenSSL PHP Extension
3. PDO PHP Extension
4. Mbstring PHP Extension
5. Tokenizer PHP Extension
6. XML PHP Extension
7. Ctype PHP Extension
8. JSON PHP Extension
9. [Composer](https://getcomposer.org/download/)

This project was created using the command:

   `composer create-project --prefer-dist laravel/laravel stock-laravel`
   
But if you have laravel installed globally, you could also create the project like this:

   `laravel new stock-laravel`

After installation, some write permissions need to be granted to a few folders.

   ``` 
   sudo chgrp -R www-data storage/ bootstrap/cache/
   
   sudo chmod -R 755 storage/ bootstrap/cache/
   ```

After the first installation, the App key will be generated automatically, however,
when cloning the repository it is necessary to generate another App key because the file 
.env will not be commited in the project. So, execute the following commands inside project root:

  ```
  cp .env.example .env
  php artisan key:generate
  ```
 
## Useful Commands

#### Configuration caching

Laravel allows configuration caching. It's useful to give the application a speed boost.

Command: `php artisan config:cache`

#### Maintenance mode

Disable the application while you are performing some maintenance.

Command: `php artisan down --message="Upgrading database"`

To disable maintenance mode: `php artisan up`

To allow specific IP even on maintenance mode: `php artisan down --allow=127.0.0.1 --allow=192.168.0.0/16`

### Run application without apache

Command: `php artisan serve`

### Set namespace

Command: `php artisan app:name stock`

## Directory Structure

   * **App** -> Application core. Almost all of your classes will be in here.
   * **Bootstrap** -> Contains the `app.php` that bootstraps all the framework.
   * **Config** -> Contains all the configuration files.
   * **Database** -> Contains db migrations, model factories and seeds.
   * **_Public_** -> Contains the entry point to the application. Also houses the assets (CSS, Javascript and images).
   * **Resources** -> Contains the views and the raw un-compiled assets (SASS, LESS).
   * **Routes** -> Contains all the route definitions. Laravel comes with some default files included:
     * `web.php` -> Provides session state, CSRF protection and cookie encryption.
     * `api.php` -> Stateless requests. Need to use tokens.
     * `console.php` -> Defines console based entry points (routes) into the application.
     * `channels.php` -> Register all the event broadcasting channels that the application supports.
   * **Storage** -> Contains the files generated by the framework. Segregated into `app`, `framework` and `logs`. The `storage/app/public` should be used to store user-generated files that should be publicly accessible (like avatars).
   * **Tests** -> Contains automated tests. Each class should be sufixed with the word `Test`. You can run the tests by executing `phpunit`.
   * **Vendor** -> Contains Composer dependencies. 
   
### Manipulating databases
   
   Laravel allows the creation of models usign artisan:
   
   `php artisan make:model Product -m`
   
   The models generate will be stored at `app/Providers`. By default, you should name the model using camel case singular nouns, while in the database it should be plural with all letters lowercase.
   The `-m` parameter also creates a migration file.
   
   **Migrations** allows the creations of databases without actually using sql CREATE. The migration file 
   To start a migration, use the command:
   
   `php artisan migrate`
   
   The generated migrations are located at `database/migrations` Before migrate, you should check the file, to manually map the columns just like in the database.
   
   By default, Laravel will map some data on the Model class without actually showing it on the code. Example: if you create a Product model, by default it will have the primary key as `id` and table name `products`.
   You can also change that by declaring `protected` variables in the class with the names `$id` and `$table`.
   
   **Seeding** is another tool that helps to populate a database with test data.
   The following command generates a seeder class inside the directory `database/seeds`:
   
   `php artisan make:seeder ProductsTableSeeder`
   
   Inside the created seeder class and inside the method `run()` you should add the code that inserts the data. For example:
   
   ```
   DB::table('products')->insert([
               'name' => str_random(25),
               'value' => rand(0, 20),
               'unit' => strtoupper(str_random(3))
           ]);
   ```
   
   And then, inside the method run at the class `DatabaseSeeder.php` (also at `database/seeds`), you should add the call to the method `run()` of the other seeder classes. For example:
   
   `$this->call(ProductsTableSeeder::class);`
   
   Now, you should execute the command that triggers the actual seeding:
   
   `php artisan db:seed`
   
   By default it will execute the `DatabaseSeeder` class, but you can use a specific seeder by using the parameter `--class`:
   
   `php artisan db:seed --class=ProductsTableSeeder`
   
   You can also rebuild the database by using the command:
   
   `php artisan migrate:refresh --seed`
   
### Middlewares

   Middleware provide a convenient mechanism for filtering HTTP requests entering your application.
   To create a new middleware, use the `make:middleware` Artisan command:
   
   `php artisan make:middleware MiddlewareName`
   
   This command will place a new middleware class within your `app/Http/Middleware` directory.
   Inside the class, there will be a method called `handle` which has to parameters: `$request` and `$next`.
   The `$request` stores data from the request, so you can, for example, get some value and compares to something in order to evaluate if the request should proceed.
   The `$next` should be used to pass the request deeper into the application, by calling the next middleware passing the request as parameter, like this:
   
   `$next($request)`
   
   You can perform tasks before the request is handled by the application:
   
   ```
   //perform some action
   
   return $next($request); 
   ```
   Or after it is handled:
   
   ```
   $response = $next($request);
  
   // Perform action
  
   return $response;
  ```
  
### Blades templates

   Blade is the simple, yet powerful templating engine provided with Laravel. 
   Blade view files use the `.blade.php` file extension and are typically stored in the `resources/views` directory.
   
   With blades, you can define parent views that children may inherit the common part and implement only the different code. This will provide more re-usability and less repetition when coding.
   
   At the _parent_ view, you should define the main code, and inside the block where the children should implement their code, you should add the `@yield('identification')`. For example:
   
   ```
   <html>
    <head></head>
    <body>
        
        @yield('content')
        
    </body>
   </html>
   ```
   
   At the _child_ view, you should define which is the parent blade by using the directive `@extends('identification')` and then define the section that should be rendered. In the end of the section, you should use the directive `@endsection`:
   
   ```
   @extends('main')
   
   @section('content')
   
   <h1>Some content from this child</h1>
   
   @endsection
   ```
   
   **Looping** can be done inside blades without using the `<?php ?>` tags. Also, using `{{}}` can replace the `<?=?>` tags to access variables results:
   
   ```
   <ul>
   @foreach($list as $item)
        <li>{{ $item->value }}</li>
   @endforeach
   </ul>
   
   <ul>
   @for($i = 0; $i < count($list); $i++)
        <li>{{ $list[$i]->value }}</li>
   @endfor
   </ul>
   
   <ul>
      @while(true)
           <li>{{ $list[$i]->value }}</li>
      @endwhile
  </ul>
   ```
   
   There is also another type of looping that can be useful to show some information when the array is empty:
   
   ```
   <ul>
   @forelse ($list as $item)
       <li>{{ $item->value }}</li>
   @empty
       <p>No items on this list</p>
   @endforelse
   </ul>
   ```
   
   You can also define default values for empty variables inside the same brackets using `or` like this:
   
   `{{ $value or 'some default value' }}`
   
   Blades also allow conditional directives:
   
   ```
   @if(false)
       <p> Do something </p>
   @elseif(false)
       <p> Do this instead </p>
   @else
       <p> Or this </p>
   @endif
   ```